  
  [1X1 [33X[0;0YPreface[133X[101X
  
  [33X[0;0YThe  [5XGAP[105X  package  [5XFSR[105X  implements Feedback Shift Registers. Feedeback shift
  registers play an important role in stream cipher design. A well known early
  example  of  an LFSRs based stream cipher is A5/1, intended for securing GSM
  voice  and data. A5/1 is built from three LFSRs with different periods and a
  stop-and-go  majority  function controlling their clocks. The A5/1 output is
  computed  as  [10XXOR[110X  of  outputs  from  all three LFSRs. A milestone in stream
  cipher  design  is  the eSTREAM project \cite{estr}, launched in 2004. All 3
  hardware  portfolio ciphers, Grain, MICKEY (using Galois-style feedback) and
  Trivium, as well as the software portfolio cipher Sosemanuk, use FSRs. Grain
  is  presented  in section \ref{grt}. The stream cipher ACORN \cite{acorn}, a
  remaining  round 3 CAESAR candidate \cite{caesar}, is based on 6 LFSRs. Last
  but  not  least,  both  stream  ciphers used for encryption and integrity of
  communications  in  mobile  networks,  Snow3G  and  ZUC,  use  LFSRs over an
  extension field.[133X
  
  [33X[0;0YAnother  application  area  for  LFSRs are the cyclic redundancy codes (CRC)
  used in many communication and data storage devices for error-detection. The
  LFSRs  have  been  used  as  counters in applications where the order of the
  sequence  does  not  matter,  for  example  Xilinx  proposed the use of LFSR
  counters  to  address  the RAM \cite{xilinxLFSR} (by now declared obsolete).
  Furthermore,  LFSRs are used for pattern generation in built-in self testing
  for  electronic  circuits.  %  NOTE:  Peterson, W. W.; Brown, D. T. (January
  1961). "Cyclic Codes for Error Detection.[133X
  
  [33X[0;0YLess  noticeable  is  the  use  of  LFSRs  in  algorithms  for  finite field
  arithmetic. For example, a serial circuit that requires multiplication by [22Xx[122X,
  followed   by  reduction  modulo  the  field  defining  polynomial,  can  be
  implemented   as   an   LFSR   with  the  defining  polynomial  as  feedback
  \cite{AHlec}.[133X
  
  
  [1X1.1 [33X[0;0YSome basic concepts[133X[101X
  
  [33X[0;0YAn  [22Xn[122X-stage  shift  register  over  a finite field [22XmathcalF[122X is an array of [22Xn[122X
  registers (denoted [22XS_t[122X, [22Xt=n-1, ...,0[122X), and each stage holds a value from the
  underlying finite field [22XmathcalF[122X. [22Xn[122X is also referred to as the length of the
  FSR.  This  memory  array  is  shifted with each step [22XS_t â†’ S_t-1[122X for [22Xt=n-1,
  dots,1[122X,  and  the vacant register [22XS_n-1[122X is updated with a new value obtained
  from  the  feedback  function, hence the name [10Xfeedback shift register[110X (FSR).
  One  of  the  stages is used to generate the output and each time the FSR is
  clocked.  The chosen stage produces a new element [22Xs_iâˆˆmathcalF[122X. In this way,
  the FSR produces a sequence of elements:[133X
  [33X[0;0Y[22Xunderlines={s_k}= s_0,s_1,s_2,dots[122X[133X
  [33X[0;0YA  simple  schematic  of  an  [22Xn[122X-stage FSR shown in figure below produces the
  output sequence from stage [22XS_0[122X.[133X
  
  [33X[0;0Y/See diagrams in HTML and PDF versions of the manual/[133X
  
  [33X[0;0YThe  feedback  function  is  a  polynomial  function  in  [22Xn[122X  variables (that
  correspond  to  the stages, i.e. variable [22Xx_t[122X takes its value from the stage
  [22XS_t[122X):[133X
  [33X[0;0Y[22Xf:mathcalF^n â†’ mathcalF[122X[133X
  [33X[0;0Y[22Xf(x_0,x_1,dots,x_n-1)        =        âˆ‘_âˆ€       (i_0,i_1,dots,i_n-1)       âˆˆ
  Z_q^nc_i_0,i_1,dots,i_n-1}x_0^i_0 x_1^i_1dots x_n-1^i_n-1}[122X[133X
  [33X[0;0Ywith  coefficients [22Xc_i_0,i_1,dots,i_n-1}âˆˆmathcalF=F_q[122X and where [22Xi_tâˆˆ Z_q[122X and
  [22Xq[122X is a prime or a prime power and [22Xtâˆˆ Z_n[122X. The sum in the equation above runs
  over all possible monomials [22Xx_0^i_0x_1^i_1dots x_n-1^i_n-1}[122X.[133X
  
  [33X[0;0YThe  degree  of  a  monomial is defined as the sum of all its powers and the
  degree  of  the  polynomial  as the maximum degree of all its monomials. For
  readability,  notation  [22Xm_i_0,i_1,dots,i_n-1}[122X  is  introduced for monomials:
  [22Xm_i_0,i_1,dots,i_n-1}=m(x_0,x_1,dots,x_n-1)=x_0^i_0x_1^i_1              dots
  x_n-1^i_n-1}[122X.[133X
  
  [33X[0;0Y[22XDegree(m(x_0,x_1,dots,x_n-1))=âˆ‘_t=0^n-1i_t[122X[133X
  
  [33X[0;0Y[22XDegree(f(x_0,x_1,dots,x_n-1))=max_âˆ€     (i_0,i_1,dots,i_n-1)âˆˆ     Z_q^n    {
  Degree(m_i_0,i_1,dots,i_n-1})}[122X[133X
  
  [33X[0;0YBased  on the degree of the feedback polynomial, distinction is made between
  [10Xlinear[110X   ([2XLFSR[102X  ([14X2.2-1[114X))  and  [10Xnonlianear[110X  ([2XNLFSR[102X  ([14X2.3-1[114X))  feedback  shift
  registers. For the linear case, the degree of the feedback polynomial is 1.[133X
  
  [33X[0;0YAt  any  given  moment,  the  contents  of  the  FSR  hold [22Xn[122X values from the
  underlying  finite  field,  and  can  be  written  as  a vector of length [22Xn[122X:
  [22X(s_0,s_1,dots,s_n-1)âˆˆmathcalF^n[122X. This vector is called the [10Xstate[110X of the FSR,
  and  the  state  right  after loading the [10Xinitial state[110X. The output sequence
  [22Xunderlines[122X  is  completely  determined  by  the  feedback polynomial and the
  initial state.[133X
  
  [33X[0;0YIn  case  of [22Xq=2[122X, [22XmathcalF=F_2[122X, function [22Xf[122X is a boolean function and the FSR
  produces  a binary sequence. In all other cases, the sequence is referred to
  as a [22Xq[122X-arry sequence.[133X
  
  [33X[0;0YTo  keep the chapter short, details will be omitted and the reader can refer
  to a number of sources such as {\cite sdgc,GGbook,lidl}.[133X
  
  
  [1X1.2 [33X[0;0YOverview[133X[101X
  
  [33X[0;0YThe FSR package allows creation, initialization and running of FSRs, and can
  compute  some  of their properties, such as length or internal state size. A
  third  object  called  FILFUN, short for ``filtering function'' was added. A
  filtering  function  is  simply  a  multivariate  function.  Because  of the
  similarities  between filtering functions and NLFSR feedbacks, the FILFUN is
  created  as an FSR object, which allows the reuse of most NLFSR methods. The
  core functionality is organized into four basic parts:[133X
  
  [30X    [33X[0;6Ycommon functionality for FSRs[133X
  
  [30X    [33X[0;6YLFSR specific functionality[133X
  
  [30X    [33X[0;6YNLFSR specific functionality[133X
  
  [30X    [33X[0;6YFILFUN specific functionality[133X
  
  [33X[0;0YThe  category  of FSR objects is defined, and the FSRs can created as LFSRs,
  NLFSRs  or  FILFUNs.  They  are created through a function call with various
  possibilities  for  the  arguments,  and  will  return  an  object with four
  components,  and  some  (case  specific) attributes and properties. Only the
  values  that  can  change  during  the  FSRs  lifetime  are  implemented  as
  components:[133X
  
  [30X    [33X[0;6Y[10Xinit[110X - initial state of the FSR[133X
  
  [30X    [33X[0;6Y[10Xstate[110X - the current state of the FSR[133X
  
  [30X    [33X[0;6Y[10Xnumsteps[110X - number of steps since object was created[133X
  
  [30X    [33X[0;6Y[10Xbasis[110X - the basis used for representation of the field elements[133X
  
  [33X[0;0YInitial  state  is kept as a component because we want the ability to reload
  and  run  the  same FSR without creating a new instance. Field [10Xinit[110X is empty
  when  the FSR is created and is updated when its loaded. The component [10Xstate[110X
  is  updated  with each FSR step. Field [10Xnumsteps[110X keeps track of the FRS: when
  created its set to -1, when loaded to 0, and then increments with each step.
  It is used for coding purposes to prevent an attempt of running an empty FRS
  and  to stop the FRS once a certain threshold is reached, preventing it from
  looping  indefinitely.  The  [10Xbasis[110X  field  holds  the current basis used for
  representation of elements and can be chained when needed.[133X
  [33X[0;0YPlease  note  that there is no concept of shifting and updating of the state
  for  the FILFUNS: the components [10Xinit[110X and [10Xstate[110X are loaded with same initial
  state,  which  is  then  used  to  evaluate  the multivariate function, i.e.
  compute  the  ``feedback''.  The computed value is the output of the FILFUN.
  Furthermore, [10Xstate[110X and [10Xnumsteps[110X are not updated.[133X
  [33X[0;0YThe behavior of an FSR is captured with three methods:[133X
  
  [30X    [33X[0;6Y[10XLoadFSR[110X - loads the initial state[133X
  
  [30X    [33X[0;6Y[10XStepFSR[110X - computes the feedback value and[133X
        [33X[0;6Y(i.) shifts stages, updates the vacant stage [22XS_n-1[122X and outputs the new
        sequence element in case of an (N)LFSR and[133X
        [33X[0;6Y(ii.) outputs the computed feedback in case of a FILFUN.[133X
  
  [30X    [33X[0;6Y[10XRunFSR[110X  -  a sequence of [10XStepFSR[110X calls (with options such as run, load
        and run, run for number of steps, ... available)[133X
  
  [33X[0;0Y[10XStepFSR[110X comes in two versions, and both are inherited by the [10XRunFSR[110X as well:[133X
  
  [30X    [33X[0;6Yregular step - FSR self-contained[133X
  
  [30X    [33X[0;6Yexternal  step  -  adds  an  external element to the computed feedback
        value[133X
  
  [33X[0;0YThe  external  step  and  run are implemented because of their common use in
  cryptography.[133X
  [33X[0;0YRemainder  of  the  FSR package consists of helper functions (for example to
  compute  the  degree  of  the  feedback  polynomial), writing functions (for
  example to print out a sequence of LFSR steps including the state changes to
  a  *.txt  file  or directly as *.tex file) and drawing functions (generating
  the  tikz  for *.tex) as is shown in figure below. /See diagrams in HTML and
  PDF versions of the manual/[133X
  
