  
  [1X1 [33X[0;0YPreface[133X[101X
  
  [33X[0;0YThe  [5XGAP[105X  package  [5XFSR[105X  implements Feedback Shift Registers. Feedeback shift
  registers play an important role in stream cipher design. A well known early
  example  of  an LFSRs based stream cipher is A5/1, intended for securing GSM
  voice  and data. A5/1 is built from three LFSRs with different periods and a
  stop-and-go  majority  function controlling their clocks. The A5/1 output is
  computed  as  [10XXOR[110X  of  outputs  from  all three LFSRs. A milestone in stream
  cipher  design is the eSTREAM project [RB08], [Est], launched in 2004. All 3
  hardware  portfolio ciphers, Grain, MICKEY (using Galois-style feedback) and
  Trivium,  as  well as the software portfolio cipher Sosemanuk, use FSRs. The
  stream  cipher  ACORN  [Wu],  a  CAESAR candidate [Cae], that made it to the
  final  portfolio,  is  based  on  6  LFSRs.  Last but not least, both stream
  ciphers  used  for  encryption  and  integrity  of  communications in mobile
  networks, Snow3G [sno] and ZUC [zuc], use LFSRs over an extension field.[133X
  
  [33X[0;0YAnother  application  area  for  LFSRs are the cyclic redundancy codes (CRC)
  used in many communication and data storage devices for error-detection. The
  LFSRs  have  been  used  as  counters in applications where the order of the
  sequence  does  not  matter,  for  example  Xilinx  proposed the use of LFSR
  counters  to  address the RAM [Alf] (by now declared obsolete). Furthermore,
  LFSRs  are  used  for  pattern  generation  in  built-in  self  testing  for
  electronic circuits.[133X
  
  [33X[0;0YLess  noticeable  is  the  use  of  LFSRs  in  algorithms  for  finite field
  arithmetic. For example, a serial circuit that requires multiplication by [22Xx[122X,
  followed   by  reduction  modulo  the  field  defining  polynomial,  can  be
  implemented as an LFSR with the defining polynomial as feedback [Has18].[133X
  
  
  [1X1.1 [33X[0;0YSome basic concepts[133X[101X
  
  [33X[0;0YAn  [22Xn[122X-stage  shift  register  over  a finite field [22XmathcalF[122X is an array of [22Xn[122X
  registers (denoted [22XS_t[122X, [22Xt=n-1, ...,0[122X), and each stage holds a value from the
  underlying finite field [22XmathcalF[122X. [22Xn[122X is also referred to as the length of the
  FSR.  This  memory  array  is  shifted with each step [22XS_t â†’ S_t-1[122X for [22Xt=n-1,
  dots,1[122X,  and  the vacant register [22XS_n-1[122X is updated with a new value obtained
  from  the  feedback  function, hence the name [10Xfeedback shift register[110X (FSR).
  One  of  the  stages is used to generate the output and each time the FSR is
  clocked.  The chosen stage produces a new element [22Xs_iâˆˆmathcalF[122X. In this way,
  the FSR produces a sequence of elements:[133X
  [33X[0;0Y[22Xunderlines={s_k}= s_0,s_1,s_2,dots[122X[133X
  [33X[0;0YA  simple  schematic  of  an  [22Xn[122X-stage FSR shown in figure below produces the
  output sequence from stage [22XS_0[122X.[133X
  
  [33X[0;0Y/See diagrams in HTML and PDF versions of the manual/[133X
  
  [33X[0;0YThe  feedback  function  is  a  polynomial  function  in  [22Xn[122X  variables (that
  correspond  to  the stages, i.e. variable [22Xx_t[122X takes its value from the stage
  [22XS_t[122X):[133X
  [33X[0;0Y[22Xf:mathcalF^n â†’ mathcalF[122X[133X
  [33X[0;0Y[22Xf(x_0,x_1,dots,x_n-1)        =        âˆ‘_âˆ€       (i_0,i_1,dots,i_n-1)       âˆˆ
  Z_q^nc_i_0,i_1,dots,i_n-1}x_0^i_0 x_1^i_1dots x_n-1^i_n-1}[122X[133X
  [33X[0;0Ywith  coefficients [22Xc_i_0,i_1,dots,i_n-1}âˆˆmathcalF=F_q[122X and where [22Xi_tâˆˆ Z_q[122X and
  [22Xq[122X is a prime or a prime power and [22Xtâˆˆ Z_n[122X. The sum in the equation above runs
  over all possible monomials [22Xx_0^i_0x_1^i_1dots x_n-1^i_n-1}[122X.[133X
  
  [33X[0;0YThe  degree  of  a  monomial is defined as the sum of all its powers and the
  degree  of  the  polynomial  as the maximum degree of all its monomials. For
  readability,  notation  [22Xm_i_0,i_1,dots,i_n-1}[122X  is  introduced for monomials:
  [22Xm_i_0,i_1,dots,i_n-1}=m(x_0,x_1,dots,x_n-1)=x_0^i_0x_1^i_1              dots
  x_n-1^i_n-1}[122X.[133X
  
  [33X[0;0Y[22XDegree(m(x_0,x_1,dots,x_n-1))=âˆ‘_t=0^n-1i_t[122X[133X
  
  [33X[0;0Y[22XDegree(f(x_0,x_1,dots,x_n-1))=max_âˆ€     (i_0,i_1,dots,i_n-1)âˆˆ     Z_q^n    {
  Degree(m_i_0,i_1,dots,i_n-1})}[122X[133X
  
  [33X[0;0YBased  on the degree of the feedback polynomial, distinction is made between
  [10Xlinear[110X   ([2XLFSR[102X  ([14X2.2-1[114X))  and  [10Xnonlianear[110X  ([2XNLFSR[102X  ([14X2.3-1[114X))  feedback  shift
  registers. For the linear case, the degree of the feedback polynomial is 1.[133X
  
  [33X[0;0YAt  any  given  moment,  the  contents  of  the  FSR  hold [22Xn[122X values from the
  underlying  finite  field,  and  can  be  written  as  a vector of length [22Xn[122X:
  [22X(s_0,s_1,dots,s_n-1)âˆˆmathcalF^n[122X. This vector is called the [10Xstate[110X of the FSR,
  and  the  state  right  after loading the [10Xinitial state[110X. The output sequence
  [22Xunderlines[122X  is  completely  determined  by  the  feedback polynomial and the
  initial state.[133X
  
  [33X[0;0YIn  case  of [22Xq=2[122X, [22XmathcalF=F_2[122X, function [22Xf[122X is a boolean function and the FSR
  produces  a binary sequence. In all other cases, the sequence is referred to
  as a [22Xq[122X-arry sequence.[133X
  
  [33X[0;0YTo  keep the chapter short, details will be omitted and the reader can refer
  to a number of sources such as [GG05],[CG12], [LN97].[133X
  
  
  [1X1.2 [33X[0;0YOverview[133X[101X
  
  [33X[0;0YThe FSR package allows creation, initialization and running of FSRs, and can
  compute  some  of their properties, such as length or internal state size. A
  third  object  called  FILFUN, short for ``filtering function'' was added. A
  filtering  function  is  simply  a  multivariate  function.  Because  of the
  similarities  between filtering functions and NLFSR feedbacks, the FILFUN is
  created  as an FSR object, which allows the reuse of most NLFSR methods (see
  [ZAG18]  for  details).  The core functionality is organized into four basic
  parts:[133X
  
  [30X    [33X[0;6Ycommon functionality for FSRs[133X
  
  [30X    [33X[0;6YLFSR specific functionality[133X
  
  [30X    [33X[0;6YNLFSR specific functionality[133X
  
  [30X    [33X[0;6YFILFUN specific functionality[133X
  
  [33X[0;0YThe  category  of  FSR  objects  is  defined, and the FSRs can be created as
  LFSRs,  NLFSRs  or  FILFUNs.  They  are created through a function call with
  various possibilities for the arguments, and will return an object with five
  components,  and  some  (case  specific) attributes and properties. Only the
  values  that  can  change  during  the  FSRs  lifetime  are  implemented  as
  components:[133X
  
  [30X    [33X[0;6Y[10Xinit[110X - initial state of the FSR[133X
  
  [30X    [33X[0;6Y[10Xstate[110X - the current state of the FSR[133X
  
  [30X    [33X[0;6Y[10Xnumsteps[110X - number of steps since object was created[133X
  
  [30X    [33X[0;6Y[10Xbasis[110X - the basis used for representation of the field elements[133X
  
  [30X    [33X[0;6Y[10Xsym[110X - the state contains symbols[133X
  
  [33X[0;0YInitial  state  is kept as a component because we want the ability to reload
  and  run  the  same FSR without creating a new instance. Field [10Xinit[110X is empty
  when  the FSR is created and is updated when its loaded. The component [10Xstate[110X
  is  updated  with each FSR step. Field [10Xnumsteps[110X keeps track of the FRS: when
  created its set to -1, when loaded to 0, and then increments with each step.
  It is used for coding purposes to prevent an attempt of running an empty FRS
  and  to stop the FRS once a certain threshold is reached, preventing it from
  looping  indefinitely.  The  [10Xbasis[110X  field  holds  the current basis used for
  representation  of elements and can be chained when needed. The field [10Xsym[110X is
  only  set  to true when symbolic computation is performed. The first example
  of symbolic FSR is shown in the example for [2XLoadFSR[102X ([14X2.1-7[114X).[133X
  [33X[0;0YPlease  note  that there is no concept of shifting and updating of the state
  for  the FILFUNs: the components [10Xinit[110X and [10Xstate[110X are loaded with same initial
  state,  which  is  then  used  to  evaluate  the multivariate function, i.e.
  compute  the  ``feedback''.  The computed value is the output of the FILFUN.
  Furthermore, [10Xstate[110X and [10Xnumsteps[110X are not updated.[133X
  [33X[0;0YThe behavior of an FSR is captured with three methods:[133X
  
  [30X    [33X[0;6Y[10XLoadFSR[110X - loads the initial state, sets [10Xsym[110X if needed.[133X
  
  [30X    [33X[0;6Y[10XStepFSR[110X - computes the feedback value and[133X
        [33X[0;6Y(i.) shifts stages [22XS_jâ†’ S_j-1[122X, [22Xj=1,dots, n-1[122X, updates the vacant stage
        [22XS_n-1[122X and outputs the new sequence element in case of an (N)LFSR and[133X
        [33X[0;6Y(ii.) outputs the computed feedback in case of a FILFUN.[133X
  
  [30X    [33X[0;6Y[10XRunFSR[110X  -  a sequence of [10XStepFSR[110X calls (with options such as run, load
        and run, run for number of steps, ... available)[133X
  
  [33X[0;0Y[10XStepFSR[110X comes in two versions, and both are inherited by the [10XRunFSR[110X as well:[133X
  
  [30X    [33X[0;6Yregular step - FSR self-contained[133X
  
  [30X    [33X[0;6Yexternal  step  -  adds  an  external element to the computed feedback
        value[133X
  
  [33X[0;0YThe  external  step  and  run are implemented because of their common use in
  cryptography.[133X
  [33X[0;0YRemainder  of  the  FSR package consists of helper functions (for example to
  compute  the  degree  of  the  feedback  polynomial), writing functions (for
  example to print out a sequence of LFSR steps including the state changes to
  a  *.txt  file  or directly as *.tex file) and drawing functions (generating
  the  tikz  for *.tex) as is shown in figure below. /See diagrams in HTML and
  PDF versions of the manual/[133X
  
  
  [1X1.3 [33X[0;0YSymbolic FSR[133X[101X
  
  [33X[0;0YWhen  the FSR package is loaded, two sets of global variables are created as
  finite   field  indeterminates  and  bound,  namely  [22Xx_0,  dots,  x_199[122X  and
  [22Xs_0,dots,s_199[122X.  The  [22Xx_k[122X  indeterminates  are intended for the entry of the
  multivariate   polynomials  used  to  define  the  FSR  objects.  Given  200
  indeterminates,   e.g.   a   200   stage  NLFSR  can  be  created.  The  [22Xs_k[122X
  indeterminates  are  intended  for  symbolic  computation  with the FSRs: we
  create  the  FSR  normally,  but then load with initial state containing the
  indeterminates  [22Xs_k[122X,  which  we  call  symbols.  Then, the FSR can be run to
  obtain  the  symbollic sequence. The symbolic sequence allows for additional
  analysis,  e.g.  for  finding  the  degree  of  the sequence elements or for
  finding  the symbolic period of the sequence. Below is a simple explample of
  an NLFSR loaded with symbolic initial state and run for 10 steps.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X   [128X[104X
    [4X[28X gap> K := GF(2);; f := x_0*x_1+x_2;; nl := NLFSR(K, f, 3);[128X[104X
    [4X[28X < empty NLFSR of length 3 over GF(2),[128X[104X
    [4X[28X  given by MultivarPoly = x_0*x_1+x_2>[128X[104X
    [4X[28X gap> ist := [s_2, s_1, s_0];; seq:=  RunFSR(nl,ist,10);[128X[104X
    [4X[28X [ s_0, s_1, s_2, s_0*s_1+s_2, s_0*s_1+s_1*s_2+s_2, s_0*s_1*s_2+s_0*s_1+s_1*s_2,[128X[104X
    [4X[28X   s_2, s_0*s_1+s_2, s_0*s_1+s_1*s_2+s_2, s_0*s_1*s_2+s_0*s_1+s_1*s_2, s_2 ][128X[104X
    [4X[28X   [128X[104X
    [4X[28X  [128X[104X
  [4X[32X[104X
  
  [33X[0;0YNOTE:  if  the  mixed  symbols/FFE  list  is  to be used in [2XLoadFSR[102X ([14X2.1-7[114X),
  [2XLoadStepFSR[102X  ([14X2.1-10[114X)  and  [2XRunFSR[102X  ([14X2.1-11[114X)) in place of [3Xist[103X or [10Xelmvec[110X, the
  list must be multiplied with [3XOne(s_0)[103X, e.g.:[133X
  
  [4X[32X  Example  [32X[104X
    [4X[28X  [128X[104X
    [4X[28X  gap> ist := [s_2, s_1, Z(2)^0]*One(s_0);; seq:=  RunFSR(nl,ist,10);[128X[104X
    [4X[28X  [ Z(2)^0, s_1, s_2, s_1+s_2, s_1*s_2+s_1+s_2, s_1, s_2, s_1+s_2,[128X[104X
    [4X[28X    s_1*s_2+s_1+s_2, s_1, s_2 ][128X[104X
    [4X[28X  [128X[104X
    [4X[28X [128X[104X
  [4X[32X[104X
  
