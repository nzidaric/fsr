% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}



\usepackage[pdftex]{graphicx}

%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{\textsf{FSR}\mbox{}}}\\
\vfill

\hypersetup{pdftitle=\textsf{FSR}}
\markright{\scriptsize \mbox{}\hfill \textsf{FSR} \hfill\mbox{}}
{\Huge \textbf{...\mbox{}}}\\
\vfill

{\Huge Version 1.0.4\mbox{}}\\[1cm]
{17 January 2017\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{Nusa Zidaric   \mbox{}}}\\
\hypersetup{pdfauthor=Nusa Zidaric   }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{Nusa Zidaric   }  Email: \href{mailto://email} {\texttt{email}}\\
  Homepage: \href{http://} {\texttt{http://}}}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 \index{FSR package@\textsf{FSR} package} The \textsf{GAP} package \textsf{FSR} ... \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 {\copyright} 2017-2017 by Nusa Zidaric, Mark Aagaard, Guang Gong

 \textsf{FSR} is free software; you can redistribute it and/or modify it under the terms of
the GNU General Public License as published by the Free Software Foundation;
either version 2 of the License, or (at your option) any later version. For
details, see the FSF's own site \href{http://www.gnu.org/licenses/gpl.html} {\texttt{http://www.gnu.org/licenses/gpl.html}}. 

 If you obtained \textsf{FSR}, we would be grateful for a short notification sent to one of the authors. 

 If you publish a result which was partially obtained with the usage of \textsf{FSR}, please cite it in the following form: 

 N. Zidaric. ... \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 ... \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Preface}}\label{Preface}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X874E1D45845007FE}{}
{
  The \textsf{GAP} package \textsf{FSR} implements Feedback Shift Registers }

 
\chapter{\textcolor{Chapter }{Output formatting functions and TEX drawing functions}}\label{Outputs}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7F7E555B782ECF45}{}
{
  
\section{\textcolor{Chapter }{Output formatting functions}}\label{Formatting}
\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7EB095598359B4B3}{}
{
  \index{outputs} There are two types of functions: ones that return the input in a human
friendly version (as strings or list of strings), and ones that write the
human friendly version of the input into a file (txt or tex) 

\subsection{\textcolor{Chapter }{ IntFFExt}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X7C848712781083D5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ IntFFExt({\mdseries\slshape [B, ]ffe})\index{ IntFFExt@\texttt{ IntFFExt}}
\label{ IntFFExt}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ IntVecFFExt({\mdseries\slshape [B, ]vec})\index{ IntVecFFExt@\texttt{ IntVecFFExt}}
\label{ IntVecFFExt}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ IntMatFFExt({\mdseries\slshape [B, ]M})\index{ IntMatFFExt@\texttt{ IntMatFFExt}}
\label{ IntMatFFExt}
}\hfill{\scriptsize (method)}}\\


 \texttt{IntFFExt} takes the \mbox{\texttt{\mdseries\slshape ffe}} and writes it as an integer of the prime field if \mbox{\texttt{\mdseries\slshape ffe}} is an element of the prime field (same as Int(ffe)), or writes it as a vector
of integers from the prime subfield if \mbox{\texttt{\mdseries\slshape ffe}} is an element of an extension field, using the given basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}} if no basis is provided. 

 \texttt{IntVecFFExt} takes the vector \mbox{\texttt{\mdseries\slshape vec}} of FFEs and writes it in a human friendly version: as a vector of integers
from the prime field if all components of \mbox{\texttt{\mdseries\slshape vec}} belong to a prime field, or as a vector of vectors of integers from the prime
subfield, if the components belong to an extension field, using the given
basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}}, if no basis is provided. (note: all components are treated as elements of
the largest field). 

 \texttt{IntMatFFExt} takes a matrix \mbox{\texttt{\mdseries\slshape M}} and returns its human friendly version: a matrix of vectors of integers from
the prime field if all components of \mbox{\texttt{\mdseries\slshape M}} belong to a prime field, or a vector of row vectors, whose elements are
vectors of integers from the prime subfield, if the components belong to an
extension field, using the given basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of components of \mbox{\texttt{\mdseries\slshape M}}. 

 NOTE: the non-basis versions return a representation in the smallest field
that contains the element. for representation in a specific field, use the
basis version with desired basis. }

 

\subsection{\textcolor{Chapter }{VecToString}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X78387B8B7940F96C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{VecToString({\mdseries\slshape [B, ]vec})\index{VecToString@\texttt{VecToString}}
\label{VecToString}
}\hfill{\scriptsize (method)}}\\


 Writes a FFE verctor or matrix as string or list of strings using the given
basis \mbox{\texttt{\mdseries\slshape B}} or canonical basis representation of \mbox{\texttt{\mdseries\slshape ffe}} if no basis is provided. This mathod calls methods \texttt{IntFFExt}, \texttt{IntVecFFExt} and \texttt{IntMatFFExt} from section LINK. The list of strings is more practically useful: we wish to
have the components as srings, therefore the human friendly version of a
matrix is not an actual string. 

 NOTE: the non-basis versions return a representation in the cononical basis of
the smallest field that contains the element. For representation in a specific
field, use the basis version with desired basis. }

 

\subsection{\textcolor{Chapter }{WriteVector (for a FFE and given basis)}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X7F4DA7FE7C10E782}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteVector({\mdseries\slshape output, B, vec})\index{WriteVector@\texttt{WriteVector}!for a FFE and given basis}
\label{WriteVector:for a FFE and given basis}
}\hfill{\scriptsize (function)}}\\


 Writes the human friendly version of vector \mbox{\texttt{\mdseries\slshape vec}} represented in basis \mbox{\texttt{\mdseries\slshape B}}, to the output file \mbox{\texttt{\mdseries\slshape output}}. Also works if \mbox{\texttt{\mdseries\slshape vec}} is an integer or FFE. 

 NOTE: the basis MUST be provided. 

 Also works for writing matrices, but writes them as a row vector, not as a
rectangle. }

 

\subsection{\textcolor{Chapter }{WriteMatrix (for a matrix of FFE and given basis)}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X7FB7643986FE0503}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteMatrix({\mdseries\slshape output, B, M})\index{WriteMatrix@\texttt{WriteMatrix}!for a matrix of FFE and given basis}
\label{WriteMatrix:for a matrix of FFE and given basis}
}\hfill{\scriptsize (function)}}\\


 Writes the human friendly version of matrix \mbox{\texttt{\mdseries\slshape M}} represented in basis \mbox{\texttt{\mdseries\slshape B}} to the output file \mbox{\texttt{\mdseries\slshape output}} nicely formatted (rectangular, each row in a new line). 

 NOTE: the basis MUST be provided. }

 

\subsection{\textcolor{Chapter }{WriteMatrixTEX}}
\logpage{[ 2, 1, 5 ]}\nobreak
\hyperdef{L}{X7C88DF8385B5C384}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WriteMatrixTEX({\mdseries\slshape output, M})\index{WriteMatrixTEX@\texttt{WriteMatrixTEX}}
\label{WriteMatrixTEX}
}\hfill{\scriptsize (function)}}\\


 Writes the TEX code for matrix \mbox{\texttt{\mdseries\slshape M}} over a prime field to the output file \mbox{\texttt{\mdseries\slshape output}}. 

 NOTE: Only works for matrices over a prime field !!! }

 }

 
\section{\textcolor{Chapter }{TEX drawing functions}}\label{Drawing}
\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X84E367F97DBA31D2}{}
{
  }

 }

 
\chapter{\textcolor{Chapter }{FSR (Feedback Shift Register)}}\label{FSR}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7D2B014884E6D3D8}{}
{
  
\section{\textcolor{Chapter }{Common functionality}}\label{fsrcommon}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7D5E0FF97CA51E2E}{}
{
  \index{fsr} We define an object \textsf{FSR} (Feedback Shift Register), which can come in two flavours: with linear
feedback \texttt{LFSR} (\ref{LFSR}) and nonlinear feedback \texttt{NLFSR} (\ref{NLFSR}). Because of many similarities between the two, the basic common functionality
can be found here, while specialized functions (such as \texttt{LFSR} and \texttt{NLFSR} object creation) in corresponding sections. 

\subsection{\textcolor{Chapter }{IsFSR}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X867B95117FAEC3E6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsFSR\index{IsFSR@\texttt{IsFSR}}
\label{IsFSR}
}\hfill{\scriptsize (filter)}}\\


 This is the category of \texttt{FSR} objects. Objects in this category are created using functions \texttt{LFSR} (\ref{LFSR}) or \texttt{NLFSR} (\ref{NLFSR}). }

 

\subsection{\textcolor{Chapter }{FieldPoly (FieldPoly)}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X83EC632C826A7CAB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FieldPoly({\mdseries\slshape fsr})\index{FieldPoly@\texttt{FieldPoly}!FieldPoly}
\label{FieldPoly:FieldPoly}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{UnderlyingField({\mdseries\slshape fsr})\index{UnderlyingField@\texttt{UnderlyingField}!UnderlyingField}
\label{UnderlyingField:UnderlyingField}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FeedbackVec({\mdseries\slshape fsr})\index{FeedbackVec@\texttt{FeedbackVec}!FeedbackVec}
\label{FeedbackVec:FeedbackVec}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{OutputTap({\mdseries\slshape fsr})\index{OutputTap@\texttt{OutputTap}!OutputTap}
\label{OutputTap:OutputTap}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{FieldPoly} of the \mbox{\texttt{\mdseries\slshape fsr}} stores the irreducible polynomial used to construct the extension field or 1
in case of a prime field.

 \texttt{UnderlyingField} of the \mbox{\texttt{\mdseries\slshape fsr}} is the finite field over which the \mbox{\texttt{\mdseries\slshape fsr}} is defined (all indeterminates and constants are from this field). 

 NOTE: it may seem redundant to sore both \texttt{FieldPoly} and \texttt{UnderlyingField}, however, they are used by other functions in the package. 

 \texttt{FeedbackVec} of the \mbox{\texttt{\mdseries\slshape fsr}} stores the coefficients of the \texttt{CharPoly} without its leading term in case of \texttt{LFSR}, and coefficients of the nonzero monomials present in the multivariate
function defining the feedback in case of \texttt{NLFSR}.

 \texttt{OutputTap} holds the output tap position(s): the sequence elements are taken from the
stage(s) listed in \texttt{OutputTap}. }

 

\subsection{\textcolor{Chapter }{Length (for an FSR)}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X8246C2AF80A0F0E9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Length({\mdseries\slshape fsr})\index{Length@\texttt{Length}!for an FSR}
\label{Length:for an FSR}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InternalStateSize({\mdseries\slshape fsr})\index{InternalStateSize@\texttt{InternalStateSize}!for an FSR}
\label{InternalStateSize:for an FSR}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{Length} of the \mbox{\texttt{\mdseries\slshape fsr}} is the number of its stages.

 \texttt{InternalStateSize} of the \mbox{\texttt{\mdseries\slshape fsr}} is size in bits needed to store the state (length * width) }

 

\subsection{\textcolor{Chapter }{LoadFSR (for an FSR)}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X81B15596784EC6D5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LoadFSR({\mdseries\slshape fsr, ist})\index{LoadFSR@\texttt{LoadFSR}!for an FSR}
\label{LoadFSR:for an FSR}
}\hfill{\scriptsize (method)}}\\


 Loading the \mbox{\texttt{\mdseries\slshape fsr}} with the initial state \mbox{\texttt{\mdseries\slshape ist}}, which is a \mbox{\texttt{\mdseries\slshape FFE}} vector of same length as \mbox{\texttt{\mdseries\slshape fsr}} and with elements from its underlying finite field. If either of those two
requirements is violated, loading fails and error message appears. At the time
of loading the initial sequence elements (ie zeroth elements) are obtained and \texttt{numsteps} is set to 0.

 }

 

\subsection{\textcolor{Chapter }{StepFSR (for an FSR)}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X87B3D9AD878A0C32}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{StepFSR({\mdseries\slshape fsr[, elm]})\index{StepFSR@\texttt{StepFSR}!for an FSR}
\label{StepFSR:for an FSR}
}\hfill{\scriptsize (method)}}\\


 Perform one step the \mbox{\texttt{\mdseries\slshape fsr}}, ie. compute the new \texttt{state} and update the \texttt{numsteps}, then output the elements denoted by \texttt{OutputTap}. If the optional parameter \mbox{\texttt{\mdseries\slshape elm}} is used then the new element is computed as a sum of computed feedback and \mbox{\texttt{\mdseries\slshape elm}}. Elemen \mbox{\texttt{\mdseries\slshape elm}} must be an element of the underlying finite field. 

 As this is a way to destroy the linearity of an \texttt{LFSR}, we refer to \texttt{StepFSR} with the optiomal nonzero \mbox{\texttt{\mdseries\slshape elm}} as \texttt{nonlinear step}. Similarly, the \texttt{NLFSR} can also have an extra element added to the (already nonlinear) feedback.

 Returns an error if the \mbox{\texttt{\mdseries\slshape fsr}} is not loaded!

 }

 

\subsection{\textcolor{Chapter }{RunFSR (for an FSR)}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X7926D97381213BB2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RunFSR({\mdseries\slshape fsr[, B, ist, num, pr]})\index{RunFSR@\texttt{RunFSR}!for an FSR}
\label{RunFSR:for an FSR}
}\hfill{\scriptsize (method)}}\\


 The \mbox{\texttt{\mdseries\slshape fsr}} will be run for a certain (\mbox{\texttt{\mdseries\slshape num}} or \mbox{\texttt{\mdseries\slshape threshold}}) number of steps: there is a threshold value, currently set to
2\texttt{\symbol{94}}\emph{Length(\mbox{\texttt{\mdseries\slshape fsr}})} + \emph{Length(\mbox{\texttt{\mdseries\slshape fsr}})}, which is used by all versions without explicit \mbox{\texttt{\mdseries\slshape num}} and enforced when \mbox{\texttt{\mdseries\slshape num}} exceeds \mbox{\texttt{\mdseries\slshape threshold}}. There is an optional printing switch \mbox{\texttt{\mdseries\slshape pr}}, with default set to \emph{false}; if \emph{true} then the state and the output sequence element(s) are printed in \textsf{GAP} shell on every step of the \mbox{\texttt{\mdseries\slshape fsr}} (we call this output for \texttt{RunFSR}), and the given basis \mbox{\texttt{\mdseries\slshape B}} is used for representation of elements. Note that having both a pint switch
and a basis is redundant, however, the additional boolean helps the method
selection to distinguish between calls with basis and calls with both initial
state \mbox{\texttt{\mdseries\slshape ist}} and the cvector of FFE elements \mbox{\texttt{\mdseries\slshape elmvec}} to be used for nonlinear steps (because all three vectors return true for
IsFFECollection). 
\begin{itemize}
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr[, B, num, pr] }})} - run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num}}/\mbox{\texttt{\mdseries\slshape threshold}} steps with/without output
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, [B,] ist[, num, pr] }})} - load \mbox{\texttt{\mdseries\slshape fsr}} with \mbox{\texttt{\mdseries\slshape ist}}, then run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num-1}}/\mbox{\texttt{\mdseries\slshape threshold}} steps with/without output (ie. \emph{linear} version)
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, [B,] elm[, num, pr] }})} - run \mbox{\texttt{\mdseries\slshape fsr}} for \mbox{\texttt{\mdseries\slshape num-1}}/\mbox{\texttt{\mdseries\slshape threshold}} steps, whereby the SAME element \mbox{\texttt{\mdseries\slshape elm}} is added to the feedback at each step, with/without output (ie. \emph{non-linear} version)
\item  \texttt{RunFSR(\mbox{\texttt{\mdseries\slshape  fsr, [B,] ist, elmvec[, pr] }})} - load \mbox{\texttt{\mdseries\slshape fsr}} with \mbox{\texttt{\mdseries\slshape ist}}, then run \mbox{\texttt{\mdseries\slshape fsr}} for \emph{Length(\mbox{\texttt{\mdseries\slshape elmvec}})} steps, whereby one element of \mbox{\texttt{\mdseries\slshape elmvec}} is added to the feedback at each step (starting with \mbox{\texttt{\mdseries\slshape elmvec[1]}}), with/without output (ie. \emph{non-linear} version). NOTE: the sequence returned has length \emph{Length(elmvec)+1}, because the zeroth sequence element is returned at the time of loading the \texttt{FSR}.
\end{itemize}
 NOTE: for the load and run versions, element seq$_0$ is a part of the output sequence The ouput of \texttt{RunFSR} is: 
\begin{itemize}
\item  sequence of \mbox{\texttt{\mdseries\slshape FFE}}s : seq$_0$, seq$_1$, seq$_2$, $\dots ,$ for \emph{Length}(\emph{OutputTap})=1
\item  sequence of vectors, each of them with $t$ \mbox{\texttt{\mdseries\slshape FFE}}s : seq$_0$, seq$_1$, seq$_2$, $\dots ,$ where seq$_i=($ seq$_{i1}$, $\dots ,$ seq$_{it}$) for \emph{Length}(\emph{OutputTap})=t
\end{itemize}
 }

 }

 
\section{\textcolor{Chapter }{LFSR specific funcionality}}\label{lfsr}
\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7A98C0FE855337A7}{}
{
  

\subsection{\textcolor{Chapter }{LFSR}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X8099A9DC86E0B078}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape F, charpol[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape K, fieldpol, charpol[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape F, charpol[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LFSR({\mdseries\slshape p, m, n[, tap]})\index{LFSR@\texttt{LFSR}}
\label{LFSR}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 An empty \texttt{LFSR} with components \texttt{init}, \texttt{state} and \texttt{numsteps} 



 Different ways to create an \texttt{LFSR} oblject, main difference is in creation of the underlying finite field. 

 Inputs: 
\begin{itemize}
\item  \mbox{\texttt{\mdseries\slshape F}} - the underlying finite field (either an extension field or a prime field)
\item  \mbox{\texttt{\mdseries\slshape charpol}} - \texttt{LFSR} dfining polynomial 
\item  \mbox{\texttt{\mdseries\slshape fieldpol}} - defifning polynomial of the extension field (must be irreducible)
\item  \mbox{\texttt{\mdseries\slshape p}} - characteeristic 
\item  \mbox{\texttt{\mdseries\slshape m}} - degree of extension (degree of \mbox{\texttt{\mdseries\slshape fieldpol}}) 
\item  \mbox{\texttt{\mdseries\slshape n}} - length of \texttt{LFSR} (degree of \mbox{\texttt{\mdseries\slshape charpoly}})
\item  \mbox{\texttt{\mdseries\slshape tap}} - optional parameter: the output tap (must be a positive integer or a list of
positive integers) and will be changed to the default S{\textunderscore}0 if
the specified integer is out of \texttt{LFSR} range.
\end{itemize}
 Compoents: 
\begin{itemize}
\item  \texttt{init} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the initial state of the \texttt{LFSR}, with indeces from n-1, ..., 0
\item  \texttt{state} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the current state of the \texttt{LFSR}, with indeces from n-1, ..., 0
\item  \texttt{numsteps} - the number of steps performed thus far (initialized to -1 when created, set
to 0 when loaded using \texttt{LoadFSR} (\ref{LoadFSR}) and incremented by 1 with each step (using \texttt{StepFSR} (\ref{StepFSR}))) 
\end{itemize}
 Attributes \texttt{FieldPoly} (\ref{FieldPoly}), \texttt{UnderlyingFied} (\ref{UnderlyingFied}), \texttt{CharPoly}, \texttt{FeedbackVec} (\ref{FeedbackVec}), \texttt{Length} (\ref{Length}) and \texttt{OutputTap} (\ref{OutputTap}) and the property \texttt{IsLinearFeedback} are set during the construction of an\texttt{LFSR}. 

 If there is something wrong with the arguments (e.g. attempting to create an
extension field using a reducible poynomial), an error message appears and the
function returns \texttt{fail}. }

 

\subsection{\textcolor{Chapter }{IsLinearFeedback (for an LFSR)}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X838DA9E4839822E6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLinearFeedback({\mdseries\slshape lfsr})\index{IsLinearFeedback@\texttt{IsLinearFeedback}!for an LFSR}
\label{IsLinearFeedback:for an LFSR}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsLFSR({\mdseries\slshape lfsr})\index{IsLFSR@\texttt{IsLFSR}!for an LFSR}
\label{IsLFSR:for an LFSR}
}\hfill{\scriptsize (filter)}}\\


 If we were to represent the \mbox{\texttt{\mdseries\slshape lsfr}} with a multivariate polynomial, DegreeOfPolynomial would return 1 - the
feedback polynomial is linear and \texttt{IsLinearFeedback} is set to \emph{true}. (ie. only linear terms are present: monomials with only one variable )

 Filter \texttt{IsLFSR} is defined as and-filter of \texttt{IsFSR} and \texttt{IsLinearFeedback}. }

 

\subsection{\textcolor{Chapter }{CharPoly (for an LFSR)}}
\logpage{[ 3, 2, 3 ]}\nobreak
\hyperdef{L}{X7DC75BE47BA3F4BE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharPoly({\mdseries\slshape lfsr})\index{CharPoly@\texttt{CharPoly}!for an LFSR}
\label{CharPoly:for an LFSR}
}\hfill{\scriptsize (attribute)}}\\


 Attribute holding the characteristic polynomial (the feedback polynomial). }

 

\subsection{\textcolor{Chapter }{IsPeriodic (for an LFSR)}}
\logpage{[ 3, 2, 4 ]}\nobreak
\hyperdef{L}{X823B75F984A72E7A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsPeriodic({\mdseries\slshape lfsr})\index{IsPeriodic@\texttt{IsPeriodic}!for an LFSR}
\label{IsPeriodic:for an LFSR}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsUltPeriodic({\mdseries\slshape lfsr})\index{IsUltPeriodic@\texttt{IsUltPeriodic}!for an LFSR}
\label{IsUltPeriodic:for an LFSR}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsMaxSeqLFSR({\mdseries\slshape lfsr})\index{IsMaxSeqLFSR@\texttt{IsMaxSeqLFSR}!for an LFSR}
\label{IsMaxSeqLFSR:for an LFSR}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Period({\mdseries\slshape lfsr})\index{Period@\texttt{Period}!for an LFSR}
\label{Period:for an LFSR}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PeriodIrreducible({\mdseries\slshape lfsr})\index{PeriodIrreducible@\texttt{PeriodIrreducible}!for an LFSR}
\label{PeriodIrreducible:for an LFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PeriodReducible({\mdseries\slshape lfsr})\index{PeriodReducible@\texttt{PeriodReducible}!for an LFSR}
\label{PeriodReducible:for an LFSR}
}\hfill{\scriptsize (method)}}\\


 Properties, attributes and methods concerning the periodicity of the output
sequence(s), generated by the \mbox{\texttt{\mdseries\slshape lsfr}}. 

 Properties: 
\begin{itemize}
\item  \texttt{IsPeriodic}: true if constant term of \texttt{CharPoly} != 0 (8.11 lidl, niederreiter) 
\item  \texttt{IsUltPeriodic}: true if \texttt{IsLFSR} is true (8.7 lidl, niederreiter) 
\item  \texttt{IsMaxSeqLFSR}: true if \texttt{CharPoly} is primitive (ref???) 
\end{itemize}
 Attributes: 
\begin{itemize}
\item  \texttt{Period}: holds the period of the UNKNOWNEntity(LFSR) 
\end{itemize}
 Methods to compute the period: 
\begin{itemize}
\item  \texttt{PeriodIrreducible}: 
\item  \texttt{PeriodReducible}: 
\end{itemize}
 }

 

\subsection{\textcolor{Chapter }{ViewObj (for an LFSR)}}
\logpage{[ 3, 2, 5 ]}\nobreak
\hyperdef{L}{X82E35D2083529319}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ViewObj({\mdseries\slshape [B, ]lfsr})\index{ViewObj@\texttt{ViewObj}!for an LFSR}
\label{ViewObj:for an LFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintObj({\mdseries\slshape [B, ]lfsr})\index{PrintObj@\texttt{PrintObj}!for an LFSR}
\label{PrintObj:for an LFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintAll({\mdseries\slshape [B, ]lfsr})\index{PrintAll@\texttt{PrintAll}!for an LFSR}
\label{PrintAll:for an LFSR}
}\hfill{\scriptsize (method)}}\\


 Different detail on the \mbox{\texttt{\mdseries\slshape lfsr}} created by \texttt{LFSR} (\ref{LFSR}): 
\begin{itemize}
\item  \texttt{Display/View}: show the \texttt{CharPoly} and wheter or not the \mbox{\texttt{\mdseries\slshape lsfr}} is empty
\item  \texttt{Print}: same as \texttt{Display/View} if \mbox{\texttt{\mdseries\slshape lsfr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps}
\item  \texttt{PrintAll}: same as \texttt{Print} if \mbox{\texttt{\mdseries\slshape lsfr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps} with additional information about the underlying field and the tap positions
\end{itemize}
 Can be used with optional parameter basis \mbox{\texttt{\mdseries\slshape B}} for desiered output format. }

 }

 
\section{\textcolor{Chapter }{NLFSR specific funcionality}}\label{nlfsr}
\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X797E9B3381339AB2}{}
{
  

\subsection{\textcolor{Chapter }{ChooseField (for a given field)}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X8040B069804A223A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ChooseField({\mdseries\slshape F})\index{ChooseField@\texttt{ChooseField}!for a given field}
\label{ChooseField:for a given field}
}\hfill{\scriptsize (function)}}\\


 Workaround for the UNKNOWNEntity(NLFSR) object definition: we need to fix the
chosen underlying finite field and prepare indeterminates in the chosen field.
The indeterminates will be used for the multivariable polynomial, which will
define the \texttt{NLFSR} feedback. Current threshold is set by global \texttt{MaxNLFSRLen} = 100. 

 }

 

\subsection{\textcolor{Chapter }{NLFSR}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X7DDE3CAC7A9D2A55}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NLFSR({\mdseries\slshape K, clist, mlist, len[, tap]})\index{NLFSR@\texttt{NLFSR}}
\label{NLFSR}
}\hfill{\scriptsize (function)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NLFSR({\mdseries\slshape K, fieldpol, clist, mlist, len[, tap]})\index{NLFSR@\texttt{NLFSR}}
\label{NLFSR}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
 An empty \texttt{NLFSR} with components \texttt{init}, \texttt{state} and \texttt{numsteps} 



 Different ways to create an \texttt{NLFSR} oblject, main difference is in creation of the underlying finite field. 

 Inputs: 
\begin{itemize}
\item  \mbox{\texttt{\mdseries\slshape F}} - the underlying finite field (either an extension field or a prime field)
\item  \mbox{\texttt{\mdseries\slshape fieldpol}} - defifning polynomial of the extension field (must be irreducible) TO DO 
\item  \mbox{\texttt{\mdseries\slshape clist}} - list of coefficients for the monomials in \mbox{\texttt{\mdseries\slshape mlist}} 
\item  \mbox{\texttt{\mdseries\slshape mlist}} - list of monomials 
\item  \mbox{\texttt{\mdseries\slshape len}} - length of \texttt{NLFSR} 
\item  \mbox{\texttt{\mdseries\slshape tap}} - optional parameter: the output tap (must be a positive integer or a list of
positive integers) and will be changed to the default S{\textunderscore}0 if
the specified integer is out of \texttt{NLFSR}range.
\end{itemize}
 NOTE: \mbox{\texttt{\mdseries\slshape clist}} and \mbox{\texttt{\mdseries\slshape mlist}} must be of same length, all elements in \mbox{\texttt{\mdseries\slshape clist}} must belong to the underlying field. Monomials in \mbox{\texttt{\mdseries\slshape mlist}} must not include any indeterminates that are out of range specified by \mbox{\texttt{\mdseries\slshape len}}: stages of \texttt{NLFSR} are represented by indeterminants and the feedback is not allowed to use a
stage that doesnt exist. A second constraint on \mbox{\texttt{\mdseries\slshape mlist}} requires that it must contain at least one monomial of degree
\${\textgreater}\$ 1, otherwise we must create an \texttt{LFSR}. 

 Compoents: 
\begin{itemize}
\item  \texttt{init} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the initial state of the \texttt{NLFSR}, with indeces from n-1, ..., 0
\item  \texttt{state} - \mbox{\texttt{\mdseries\slshape FFE}} vector of length n=deg(charpol), storing the current state of the \texttt{NLFSR}, with indeces from n-1, ..., 0
\item  \texttt{numsteps} - the number of steps performed thus far (initialized to -1 when created, set
to 0 when loaded using \texttt{LoadFSR} (\ref{LoadFSR}) and incremented by 1 with each step (using \texttt{StepFSR} (\ref{StepFSR}))) 
\end{itemize}
 Attributes \texttt{FieldPoly} (\ref{FieldPoly}), \texttt{UnderlyingFied} (\ref{UnderlyingFied}), \texttt{MultivarPoly}, \texttt{FeedbackVec} (\ref{FeedbackVec}), \texttt{IndetList} (\ref{IndetList}), \texttt{Length} (\ref{Length}) and \texttt{OutputTap} (\ref{OutputTap}) and the property \texttt{IsNonLinearFeedback} are set during the construction of an \texttt{NLFSR}. 

 If there is something wrong with the arguments (e.g. attempting to create an
extension field using a reducible poynomial), an error message appears and the
function returns \texttt{fail}. }

 

\subsection{\textcolor{Chapter }{IsNonLinearFeedback (for an NLFSR)}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X8567C55480B968AB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNonLinearFeedback({\mdseries\slshape nlfsr})\index{IsNonLinearFeedback@\texttt{IsNonLinearFeedback}!for an NLFSR}
\label{IsNonLinearFeedback:for an NLFSR}
}\hfill{\scriptsize (property)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsNLFSR({\mdseries\slshape nlfsr})\index{IsNLFSR@\texttt{IsNLFSR}!for an NLFSR}
\label{IsNLFSR:for an NLFSR}
}\hfill{\scriptsize (filter)}}\\


 For the multivariate polynomial given by \mbox{\texttt{\mdseries\slshape clist}} and \mbox{\texttt{\mdseries\slshape mlist}}, DegreeOfPolynomial greter than 1 sets \texttt{IsNonLinearFeedback} to \emph{true}. otherwise it prints out a warning that you need to use the \texttt{LFSR} constructor instead. 

 Filter \texttt{IsNLFSR} is defined as and-filter of \texttt{IsFSR} and \texttt{IsNonLinearFeedback}. 

 NOTE: at the same time \texttt{IsLinearFeedback} is set to \emph{false} (for coding purposes). }

 

\subsection{\textcolor{Chapter }{MultivarPoly (for an NLFSR)}}
\logpage{[ 3, 3, 4 ]}\nobreak
\hyperdef{L}{X840B27137E4B68C9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MultivarPoly({\mdseries\slshape nlfsr})\index{MultivarPoly@\texttt{MultivarPoly}!for an NLFSR}
\label{MultivarPoly:for an NLFSR}
}\hfill{\scriptsize (attribute)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IndetList({\mdseries\slshape nlfsr})\index{IndetList@\texttt{IndetList}!for an NLFSR}
\label{IndetList:for an NLFSR}
}\hfill{\scriptsize (attribute)}}\\


 \texttt{MultivarPoly} holds the multivariate function defining the feedback of the \texttt{NLFSR}. \texttt{IndetList} holds all the indeterminates that are present in \texttt{MultivarPoly} and \texttt{FeedbackVec} holds only the nonzero coefficients (as opposed to the \texttt{LFSR}, where this field holds coefficients for all stages of the \texttt{FSR}). The feedback element is computed from \texttt{MultivarPoly}, \texttt{IndetList} and \texttt{state}, and not from \texttt{FeedbackVec}. }

 

\subsection{\textcolor{Chapter }{ViewObj (for an NLFSR)}}
\logpage{[ 3, 3, 5 ]}\nobreak
\hyperdef{L}{X836CA53B872FD8B6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ViewObj({\mdseries\slshape [B, ]nlfsr})\index{ViewObj@\texttt{ViewObj}!for an NLFSR}
\label{ViewObj:for an NLFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintObj({\mdseries\slshape [B, ]nlfsr})\index{PrintObj@\texttt{PrintObj}!for an NLFSR}
\label{PrintObj:for an NLFSR}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{PrintAll({\mdseries\slshape [B, ]nlfsr})\index{PrintAll@\texttt{PrintAll}!for an NLFSR}
\label{PrintAll:for an NLFSR}
}\hfill{\scriptsize (method)}}\\


 Different detail on \mbox{\texttt{\mdseries\slshape nlfsr}} created by \texttt{NLFSR} (\ref{NLFSR}): 
\begin{itemize}
\item  \texttt{Display/View}: show the \texttt{MultivarPoly} and wheter or not the \mbox{\texttt{\mdseries\slshape nlfsr}} is empty
\item  \texttt{Print}: same as \texttt{Display/View} if \mbox{\texttt{\mdseries\slshape nlfsr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps}
\item  \texttt{PrintAll}: same as \texttt{Print} if \mbox{\texttt{\mdseries\slshape nlfsr}} is empty, otherwise it also shows the values of the three components \texttt{init}, \texttt{state} and \texttt{numsteps} with additional information about the underlying field and the tap positions
\end{itemize}
 Can be used with optional parameter basis \mbox{\texttt{\mdseries\slshape B}} for desiered output format. }

 }

 }

 
\chapter{\textcolor{Chapter }{misc - helper functions}}\label{misc}
\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X82DB6D4585397594}{}
{
  
\section{\textcolor{Chapter }{misc - helper functions}}\label{misc}
\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X82DB6D4585397594}{}
{
  

\subsection{\textcolor{Chapter }{MonomialsOverField (for an NLFSR)}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X7CF7FC2182FEA652}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MonomialsOverField({\mdseries\slshape F, poly})\index{MonomialsOverField@\texttt{MonomialsOverField}!for an NLFSR}
\label{MonomialsOverField:for an NLFSR}
}\hfill{\scriptsize (method)}}\\


 MonomialsOverField reduces takes a monomial or a list of monomials, and
reduces all the exponents modulo (Size(\mbox{\texttt{\mdseries\slshape F}})-1) for all extension fields and prime fields except for \mbox{\texttt{\mdseries\slshape F}}=$\mathcal(F)_2$. For $\mathcal(F)_2$ all the exponents are set to 1. }

 

\subsection{\textcolor{Chapter }{DegreeOfPolynomial (DegreeOfPolynomial)}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X85A860DA845F6090}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DegreeOfPolynomial({\mdseries\slshape F, poly})\index{DegreeOfPolynomial@\texttt{DegreeOfPolynomial}!DegreeOfPolynomial}
\label{DegreeOfPolynomial:DegreeOfPolynomial}
}\hfill{\scriptsize (method)}}\\


 \texttt{DegreeOfPolynomial} as follows for both monomial of form $p = \prod x_i^{e_i}$ and polynomial of form $P = \sum c_j\cdotp_j$ where $p_j = \prod_{i}x_i^{e_i}$ DegreeOfPolynomial for a monomial: $= \sum e_i$, where $i$ runs through all indeterminates present in this monomial DegreeOfPolynomial
for a polynomial: $= \max (DegreeOfPolynomial(p_j))$ , where $\max$ runs through all monomials $p_j$ present in this polynomial so an actual extra funstion called DegreeOfMonomial
is not needed }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{manual}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
