<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (fsr) - Chapter 3: Output formatting functions and writing functions</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3.html">[MathJax off]</a></p>
<p><a id="X82117EA97FE29738" name="X82117EA97FE29738"></a></p>
<div class="ChapSects"><a href="chap3_mj.html#X82117EA97FE29738">3 <span class="Heading">Output formatting functions and writing functions</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X7EB095598359B4B3">3.1 <span class="Heading">Output formatting functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X815BF22186FD43C9">3.1-1 ViewObj</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C848712781083D5">3.1-2 IntFFExt</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X78387B8B7940F96C">3.1-3 VecToString</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X780D930685529590">3.2 <span class="Heading">Writing and TEX writing functions</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C133E9484FC89C9">3.2-1 WriteFFEVec</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X79D54F997F1F9C7E">3.2-2 WriteTEXFF</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X816AAD7A78698EA6">3.2-3 WriteTEXUnivarFFPolyByGenerator</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X805B77C47BAB06DC">3.2-4 WriteTEXGeneratorWRTDefiningPolynomial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X78180B88800FA409">3.2-5 WriteAllFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X79E7AA0478BA4482">3.2-6 WriteSequenceFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7C33BF5C835DBEEC">3.2-7 WriteRunFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7B88931878142E55">3.2-8 WriteTEXRunFSR</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3_mj.html#X8529AFE3849442AB">3.3 <span class="Heading">TEX drawing functions for (N)LFSRs</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X7F43CAC08616D8FE">3.3-1 TikzW_LFSR</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3_mj.html#X848A126786051CAF">3.3-2 TikzW_NLFSR</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Output formatting functions and writing functions</span></h3>

<p><a id="X7EB095598359B4B3" name="X7EB095598359B4B3"></a></p>

<h4>3.1 <span class="Heading">Output formatting functions</span></h4>

<p><a id="X815BF22186FD43C9" name="X815BF22186FD43C9"></a></p>

<h5>3.1-1 ViewObj</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ViewObj</code>( <var class="Arg">fsr</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintObj</code>( <var class="Arg">fsr</var>[, <var class="Arg">b</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PrintAll</code>( <var class="Arg">fsr</var>[, <var class="Arg">b</var>] )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Different detail on <var class="Arg">fsr</var> created either by <code class="func">LFSR</code> (<a href="chap2_mj.html#X8099A9DC86E0B078"><span class="RefLink">2.2-1</span></a>) or <code class="func">NLFSR</code> (<a href="chap2_mj.html#X7DDE3CAC7A9D2A55"><span class="RefLink">2.3-1</span></a>):</p>


<ul>
<li><p><code class="code">Display/View</code>:</p>


<ul>
<li><p>LFSR: show the <code class="func">FeedbackPoly</code> (<a href="chap2_mj.html#X796665E583387AB3"><span class="RefLink">2.2-3</span></a>) and wheter or not the <var class="Arg">fsr</var> is empty.</p>

</li>
<li><p>NLFSR: show the <code class="func">MultivarPoly</code> (<a href="chap2_mj.html#X7C6FCBDC82C3734E"><span class="RefLink">2.3-3</span></a>) and wheter or not the <var class="Arg">fsr</var> is empty.</p>

</li>
<li><p>FILFUN: show the <code class="func">MultivarPoly</code> (<a href="chap2_mj.html#X7C6FCBDC82C3734E"><span class="RefLink">2.3-3</span></a>).</p>

</li>
</ul>
</li>
<li><p><code class="code">Print</code>: same as <code class="code">Display/View</code> if <var class="Arg">fsr</var> is empty, otherwise it also shows the values of components <code class="code">state</code>, <code class="code">numsteps</code> and <code class="code">basis</code>.</p>

</li>
<li><p><code class="code">PrintAll</code>: same as <code class="code">Print</code> if <var class="Arg">fsr</var> is empty, otherwise it also shows the values of all four components <code class="code">init</code>, <code class="code">state</code> , <code class="code">numsteps</code> and <code class="code">basis</code> with additional information about the underlying field and the tap positions .</p>

</li>
</ul>
<p>NOTE: both <code class="code">Print</code> and <code class="code">PrintAll</code> can be used with optional parameter <var class="Arg">b</var> for desiered output format: when <code class="code">true</code> the output will use the currently set basis. When <var class="Arg">fsr</var> is symbolic, the basis switch <var class="Arg">b</var> is ignored.</p>

<p>Examples below show different outputs for an LFSR:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K := GF(2);; x := X(K, "x");; f := x^4 + x^3 + 1;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FieldExtension(K, f);; y := X(F, "y");; l := y^4 + y + Z(2^4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := LFSR(K, f, l);; Print(test);</span>
empty LFSR over GF(2^4) given by FeedbackPoly = y^4+y+Z(2^4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ist := [ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ];; LoadFSR(test, ist);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(test);</span>
LFSR over GF(2^4)  given by FeedbackPoly = y^4+y+Z(2^4)
with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
with current state =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
after  0 steps
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RunFSR(test,5);; Print(test);</span>
LFSR over GF(2^4)  given by FeedbackPoly = y^4+y+Z(2^4)
with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
with current state =[ Z(2^2), Z(2^4)^2, Z(2^4)^2, Z(2^4)^11 ]
after  5 steps
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintAll(test);</span>
LFSR over GF(2^4)  given by FeedbackPoly = y^4+y+Z(2^4)
with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
with feedback coeff =[ 0*Z(2), 0*Z(2), Z(2)^0, Z(2^4) ]
with initial state  =[ 0*Z(2), Z(2^4), Z(2^2), Z(2)^0 ]
with current state  =[ Z(2^2), Z(2^4)^2, Z(2^4)^2, Z(2^4)^11 ]
after 5 steps
with output from stage S_0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PrintAll(test, true);</span>
LFSR over GF(2^4) defined by FieldPoly=x^4+x^3+Z(2)^0  given by FeedbackPoly = \
y^4+y+Z(2^4)
with basis =[ Z(2)^0, Z(2^4)^7, Z(2^4)^14, Z(2^4)^6 ]
with feedback coeff =[ [ 0, 0, 0, 0 ], [ 0, 0, 0, 0 ], [ 1, 0, 0, 0 ],
  [ 0, 1, 1, 0 ] ]
with initial state  =[ [ 0, 0, 0, 0 ], [ 0, 1, 1, 0 ], [ 1, 1, 0, 1 ],
  [ 1, 0, 0, 0 ] ]
with current state  =[ [ 1, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 1, 0, 1, 1 ],
  [ 0, 1, 1, 1 ] ]
after 5 steps
with output from stage S_0

</pre></div>

<p>Examples below show outputs for an NLFSR and a FILFUN:</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := GF(2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">clist := [One(F), One(F)];; mlist := [x_0, x_1*x_2];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">test := NLFSR(F, clist, mlist, 3);</span>
&lt; empty NLFSR of length 3 over GF(2),
  given by MultivarPoly = x_1*x_2+x_0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(test);</span>
&lt; empty NLFSR of length 3 over GF(2),
  given by MultivarPoly = x_1*x_2+x_0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> test := FILFUN(F, clist, mlist);; PrintAll(test);</span>
FILFUN of length 3 over GF(2),
  with the MultivarPoly = x_1*x_2+x_0
with basis =[ Z(2)^0 ]
with current state  =[ 0*Z(2), 0*Z(2), 0*Z(2) ]

</pre></div>

<p><a id="X7C848712781083D5" name="X7C848712781083D5"></a></p>

<h5>3.1-2 IntFFExt</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntFFExt</code>( [<var class="Arg">B</var>, ]<var class="Arg">ffe</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntVecFFExt</code>( [<var class="Arg">B</var>, ]<var class="Arg">vec</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntMatFFExt</code>( [<var class="Arg">B</var>, ]<var class="Arg">M</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p><code class="code">IntFFExt</code> takes the <var class="Arg">ffe</var> and writes it as an integer of the prime field f <var class="Arg">ffe</var> is an element of the prime field (same as Int(ffe)), or writes it as a vector of integers from the prime subfield if <var class="Arg">ffe</var> is an element of an extension field, using the given basis <var class="Arg">B</var> or canonical basis representation of <var class="Arg">ffe</var> if no basis is provided.</p>

<p><code class="code">IntVecFFExt</code> takes the vector <var class="Arg">vec</var> of FFEs and writes it in a human friendly version: as a vector of integers from the prime field if all components of <var class="Arg">vec</var> belong to a prime field, or as a vector of vectors of integers from the prime subfield, if the components belong to an extension field, using the given basis <var class="Arg">B</var> or canonical basis representation of <var class="Arg">ffe</var>, if no basis is provided. (note: all components are treated as elements of the largest field).</p>

<p><code class="code">IntMatFFExt</code> takes a matrix <var class="Arg">M</var> and returns its human friendly version: a matrix of vectors of integers from the prime field if all components of <var class="Arg">M</var> belong to a prime field, or a vector of row vectors, whose elements are vectors of integers from the prime subfield, if the components belong to an extension field, using the given basis <var class="Arg">B</var> or canonical basis representation of components of <var class="Arg">M</var>.</p>

<p>NOTE: the non-basis versions return a representation in the smallest field that contains the element. For representation in a specific field, use the basis version with desired basis.</p>

<p><a id="X78387B8B7940F96C" name="X78387B8B7940F96C"></a></p>

<h5>3.1-3 VecToString</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VecToString</code>( [<var class="Arg">B</var>, ]<var class="Arg">vec</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Writes a FFE verctor or matrix as string or list of strings using the given basis <var class="Arg">B</var> or canonical basis representation of <var class="Arg">ffe</var> if no basis is provided. This mathod calls methods <code class="func">IntFFExt</code> (<a href="chap3_mj.html#X7C848712781083D5"><span class="RefLink">3.1-2</span></a>), <code class="func">IntVecFFExt</code> (<a href="chap3_mj.html#X7C848712781083D5"><span class="RefLink">3.1-2</span></a>) and <code class="func">IntMatFFExt</code> (<a href="chap3_mj.html#X7C848712781083D5"><span class="RefLink">3.1-2</span></a>). The list of strings is more practically useful: we wish to have the components as srings, therefore the human friendly version of a matrix is not an actual string.</p>

<p>NOTE: the non-basis versions return a representation in the cononical basis of the smallest field that contains the element. For representation in a specific field, use the basis version with desired basis.</p>

<p><a id="X780D930685529590" name="X780D930685529590"></a></p>

<h4>3.2 <span class="Heading">Writing and TEX writing functions</span></h4>

<p>There are two types of functions for writing to a files, ones without special formatting (e.g. *.txt file), and the ones with TEX formatting (e.g. can be used directly in *.tex files). The followng tex packages must be used: <em>array, amssymb, amsmath</em>.</p>

<p>Some of the common inputs to the writing functions:</p>


<ul>
<li><p><var class="Arg">output</var> - output stream file (e.g., txt)</p>

</li>
<li><p><var class="Arg">fsr</var> - the FSR</p>

</li>
<li><p><var class="Arg">F</var>, <var class="Arg">ffe</var>, <var class="Arg">vec</var>, <var class="Arg">M</var> - a finite field , a field element, a vector, a matrix.</p>

</li>
<li><p><var class="Arg">B</var>, <var class="Arg">b</var> - basis used for representation of the elmenets, and the basis print switch, indicating whether or not to use <var class="Arg">B</var>.</p>

</li>
<li><p><var class="Arg">gen</var>, <var class="Arg">strGen</var> - generator of the underlying field and the greek letter string for tex, e.g. "alpha", to represent the generator. Will be used for the representation of the elements as a power of <var class="Arg">gen</var>. Only relevant for the TEX writing functions.</p>

</li>
</ul>
<p>The TEX functions only write the fileds, field elements and polynomials formatted for *.tex files. Field elements are represented either w.r.t. a given basis <var class="Arg">B</var> or as a power of a generator <var class="Arg">gen</var> of the finite field <var class="Arg">F</var>. The generator <var class="Arg">gen</var> is used to get the exponents of the elements, and the elements themselfs are printed as e.g. <span class="SimpleMath">\(\alpha^{exponent}\)</span>, where <var class="Arg">strGen</var> is set to "alpha" ( it must be a string representing a greek letter in *.tex).</p>

<p>A full example of the various WriteTEX* functions can be seen in figures at the end of this section.</p>

<p><a id="X7C133E9484FC89C9" name="X7C133E9484FC89C9"></a></p>

<h5>3.2-1 WriteFFEVec</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteFFEVec</code>( <var class="Arg">output</var>, <var class="Arg">B</var>, <var class="Arg">vec</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteFFEMatrix</code>( <var class="Arg">output</var>, <var class="Arg">B</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteFFEVector</code> writes the human friendly version of vector <var class="Arg">vec</var> represented in basis <var class="Arg">B</var>, to the output file <var class="Arg">output</var>. Also works if <var class="Arg">vec</var> is an integer or FFE. Can be used to write the sequence produced by the FSR to a file, but the list (the sequence) shall not contain any sublists (i.e. flatten the list first). Also works for writing matrices, but writes them as a row vector, not as a ``rectangle''.</p>

<p><code class="code">WriteFFEMatrix</code> writes the human friendly version of matrix <var class="Arg">M</var> represented in basis <var class="Arg">B</var> to the output file <var class="Arg">output</var> nicely formatted (rectangular, each row in a new line).</p>

<p><a id="X79D54F997F1F9C7E" name="X79D54F997F1F9C7E"></a></p>

<h5>3.2-2 WriteTEXFF</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFF</code>( <var class="Arg">output</var>, <var class="Arg">F</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFFE</code>( <var class="Arg">output</var>, <var class="Arg">B</var>, <var class="Arg">ffe</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFFEVec</code>( <var class="Arg">output</var>, <var class="Arg">B</var>, <var class="Arg">vec</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFFEMatrix</code>( <var class="Arg">output</var>, <var class="Arg">B</var>, <var class="Arg">M</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFFEByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">ffe</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFFEVecByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">vec</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFFEMatrixByGnerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">M</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXSymVecByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">vec</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteTEXFF</code> writes the field in TEX format, e.g. <span class="SimpleMath">\(\mathbb{F}_{2}\)</span>, <span class="SimpleMath">\(\mathbb{F}_{{2}^{2}}\)</span> or <span class="SimpleMath">\(\mathbb{F}_{(({2}^{2})^{2})^{2}}\)</span>.</p>

<p><code class="code">WriteTEXFFE</code> writes the <var class="Arg">ffe</var> w.r.t the chosen basis <var class="Arg">B</var>.</p>

<p><code class="code">WriteTEXFFEVec</code> writes the vector <var class="Arg">vec</var> with elements w.r.t the chosen basis <var class="Arg">B</var>.</p>

<p><code class="code">WriteTEXFFEMat</code> writes the matrix <var class="Arg">M</var> with elements w.r.t the chosen basis <var class="Arg">B</var>.</p>

<p>Analogue to the last three ``basis'' writing functions are the functions <code class="code">WriteTEXFFEByGenerator</code>, <code class="code">WriteTEXFFEVecByGenerator</code> and <code class="code">WriteTEXFFEMatrixByGnerator</code>, that write the field elements a power of a chosen generator <var class="Arg">gen</var> of the field <var class="Arg">F</var> (to avoid using a generator of the subfield in case <var class="Arg">ffe</var> is a subfield element).</p>

<p>NOTE: for both WriteTEXFFEMatrix functions the math environment wrappers, e.g. <em>\begin{displaymath}</em> and <em>\end{displaymath}</em> must be added manually!</p>

<p><code class="code">WriteTEXSymVecByGenerator</code> writes every element of the vector <var class="Arg">vec</var>with symbols <span class="SimpleMath">\(s_1,\dots,s_{199}\)</span> and all coefficients as powers of the chosen generator <var class="Arg">gen</var>.</p>

<p>NOTE: if the vector contains FFE constants, use <span class="SimpleMath">\(vec*One(s_0)\)</span> as as the input to the writing function.</p>

<p><a id="X816AAD7A78698EA6" name="X816AAD7A78698EA6"></a></p>

<h5>3.2-3 WriteTEXUnivarFFPolyByGenerator</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXUnivarFFPolyByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">f</var>, <var class="Arg">strIndet</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXFieldPolyByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">f</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXLFSRPolyByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">f</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXMultivarFFPolyByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">mpoly</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteTEXUnivarFFPolyByGenerator</code> writes the polynomial <var class="Arg">f</var> in terms of indeterminate <var class="Arg">strIndent</var>, given as a string, and with coefficients as powers of a chosen generator <var class="Arg">gen</var> of the field <var class="Arg">F</var> (to avoid using a generator of the subfield in case a coefficient is a subfield element).</p>

<p><code class="code">WriteTEXFieldPolyByGenerator</code> and <code class="code">WriteTEXLFSRPolyByGenerator</code> call <code class="code">WriteTEXUnivarFFPolyByGenerator</code> with <var class="Arg">strIndet</var> set to "x" and "y" respectively.</p>

<p><code class="code">WriteTEXMultivarFFPolyByGenerator</code> writes the multuivariate polynomial <var class="Arg">mpoly</var> with indterminates <span class="SimpleMath">\(x_0, \dots, x_{199}\)</span> or <span class="SimpleMath">\(s_0, \dots, s_{199}\)</span> (mix of <span class="SimpleMath">\(x_i\)</span> and <span class="SimpleMath">\(s_i\)</span> is not supported). The coefficients are written as powers of a chosen generator <var class="Arg">gen</var>.</p>

<p><a id="X805B77C47BAB06DC" name="X805B77C47BAB06DC"></a></p>

<h5>3.2-4 WriteTEXGeneratorWRTDefiningPolynomial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXGeneratorWRTDefiningPolynomial</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXBasisByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">B</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXElementTableByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">F</var>, <var class="Arg">B</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteTEXGeneratorWRTDefiningPolynomial</code> either writes that <var class="Arg">gen</var> as a root of the defining polynomial of <var class="Arg">F</var> if that is the case, otherwise it writes the generator <var class="Arg">gen</var> in polynomial basis of the field <var class="Arg">F</var> given by the root <span class="SimpleMath">\(\omega\)</span> of the defining polynomial of <var class="Arg">F</var>.</p>

<p>NOTE: In the FSR package, "omega" is the reserved greek letter for the root of the defining polynomial <var class="Arg">strGen</var>. Please make sure that if using "omega" as <var class="Arg">strGen</var>, gen is the root of defining polynomial.</p>

<p><code class="code">WriteTEXBasisByGenerator</code> prints the elements of the given basis <var class="Arg">B</var> as powers of a chosen generator <var class="Arg">gen</var>.</p>

<p><code class="code">WriteTEXElementTableByGenerator</code> provides the context information for <code class="code">WriteTEXSequenceByGenerator</code> and <code class="code">WriteTEXRunFSRByGenerator</code>. Its output is a *.tex file with a table containing the elements of <var class="Arg">F</var> represented in basis <var class="Arg">B</var> and their representation as powers of a chosen generator <var class="Arg">gen</var> in column <span class="SimpleMath">\(\alpha^{i}\)</span>, where <var class="Arg">strGen</var> is set to "alpha". Use of "omega" is not allowed. There is an extra table column containing the order of each element. The output file contains additional information, e.g. the defining polynomial of <var class="Arg">F</var>, basis elements of <var class="Arg">B</var> as powers of generator <var class="Arg">gen</var>.</p>

<p><img src="WriteTEX.jpg" align="center" /> <img src="WriteTEXelmTablesnap.jpg" align="center" /></p>

<p><a id="X78180B88800FA409" name="X78180B88800FA409"></a></p>

<h5>3.2-5 WriteAllFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteAllFSR</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">b</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXAllFSR</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">b</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteAllFSR</code> is equivalent to PrintAll, but it writes to an output stream (like a *.txt file).</p>

<p><code class="code">WriteTEXAllFSR</code> is equivalent to PrintAll, but formats the output for *.tex files.</p>

<p>NOTE: both versions must be used with <em>mandatory</em> basis switch parameter <var class="Arg">b</var> for desiered output format: when <code class="code">true</code> the output will use the currently set basis. If the FSR is symbolic, <var class="Arg">b</var> is ignored, i.e. behaves like <code class="code">false</code>.</p>

<p><a id="X79E7AA0478BA4482" name="X79E7AA0478BA4482"></a></p>

<h5>3.2-6 WriteSequenceFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteSequenceFSR</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">sequence</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTBSequenceFSR</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">sequence</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXSequence</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">sequence</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXSequenceByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">sequence</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteSequenceFSR</code> writes the sequence generated by some version of RunFSR(lfsr) to an output file, with addition of separating sequences from different taps. The sequence elements are written in the currently set basis of the <var class="Arg">fsr</var> or symbolically.</p>

<p><code class="code">WriteTBSequenceFSR</code> is a version of <code class="code">WriteSequenceFSR</code> intended for testbenching purposes: the generated sequence is written to a file, with sequences from different taps separated into <em>columns</em>. The order of columns is determined by <code class="code">OutputTap(<var class="Arg">fsr</var>)</code>. The currently set basis of the <var class="Arg">fsr</var> is used for the sequence elements, a symbolic version is not possible.</p>

<p><code class="code">WriteTEXSequence</code> and <code class="code">WriteTEXSequenceByGenerator</code> are *.tex versions of <code class="code">WriteSequenceFSR</code>, writing the sequence elements w.r.t. the currently set basis of the <var class="Arg">fsr</var> or as powers of a chosen generator <var class="Arg">gen</var>.</p>

<p><code class="code">WriteTEXSequenceByGenerator</code> is the only function that can write a symbollic sequence, however, due to the length of the sequence elements, formatting problems may arise .</p>

<p>NOTE: if the symbollic sequence contains FFE constants, use <span class="SimpleMath">\(sequence*One(s_0)\)</span> as the input to the writing function.</p>

<p><a id="X7C33BF5C835DBEEC" name="X7C33BF5C835DBEEC"></a></p>

<h5>3.2-7 WriteRunFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteRunFSR</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">numsteps</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteExternalRunFSR</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">elmvec</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteRunFSR</code> is an output to a file version of RunFSR(<var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">num</var>), see <code class="func">RunFSR</code> (<a href="chap2_mj.html#X86AAB63D8781648A"><span class="RefLink">2.1-11</span></a>) for details. <code class="code">WriteRunFSR</code> separates the sequences from different taps and writes them in currently set basis of the <var class="Arg">fsr</var> or symbolically. After the FSR is loaded, the <code class="code">WriteAllFSR(output, x, true)</code> is called to record the FSR being used. When the run is finished, <code class="code">WriteSequenceFSR</code> is called to record the output sequence in compact version. <code class="code">WriteRunFSR</code> returns the sequence generated by this run.</p>

<p><code class="code">WriteExternalRunFSR</code> is an output to a file version of <code class="code">RunFSR(<var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">elmvec</var>)</code> with an external element added on each step.</p>

<p>An example of the the <code class="code">WriteRunFSR</code> output can be seen in figure below:</p>

<p><img src="WriteRunFSR1.jpg" align="center" /></p>

<p>NOTE: does not work properly if the basis is given over any subfield other than the prime subfied.</p>

<p>NOTE: does not work for <var class="Arg">fsr</var> of type FILFUN !</p>

<p><a id="X7B88931878142E55" name="X7B88931878142E55"></a></p>

<h5>3.2-8 WriteTEXRunFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXRunFSR</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">nums</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WriteTEXRunFSRByGenerator</code>( <var class="Arg">output</var>, <var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">nums</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">WriteTEXRunFSR</code> is an output to a *.tex file version of RunFSR(<var class="Arg">fsr</var>, <var class="Arg">ist</var>, <var class="Arg">num</var>), see <code class="func">RunFSR</code> (<a href="chap2_mj.html#X86AAB63D8781648A"><span class="RefLink">2.1-11</span></a>) for details. It writes a table that can be included dircetly (except for the label). Rows of the table represent the steps of the FSR and include the state of the FSR and the elements from stages specfied by outputTap, that is the sequence outputs at this step. The table entries (FFEs) are printed using currently set basis of the <var class="Arg">fsr</var>. When the run is finished, <code class="code">WriteTEXSequence</code> is called to record the output sequence in compact version. <code class="code">WriteTEXRunFSR</code> returns the sequence generated by this run.</p>

<p><code class="code">WriteTEXRunFSRByGenerator</code> writes all the elements as powers of the generator <var class="Arg">gen</var>.</p>

<p>NOTE: does not work for symbolic FSRs, however, all the components and the output sequence can be written to a *.tex file using calls <code class="func">WriteTEXSymVecByGenerator</code> (<a href="chap3_mj.html#X79D54F997F1F9C7E"><span class="RefLink">3.2-2</span></a>) and <code class="func">WriteTEXSequenceByGenerator</code> (<a href="chap3_mj.html#X79E7AA0478BA4482"><span class="RefLink">3.2-6</span></a>).</p>

<p>NOTE: does not work for <var class="Arg">fsr</var> of type FILFUN !</p>

<p><img src="WriteTEXRunFSR2.jpg" align="center" /></p>

<p><a id="X8529AFE3849442AB" name="X8529AFE3849442AB"></a></p>

<h4>3.3 <span class="Heading">TEX drawing functions for (N)LFSRs</span></h4>

<p>The drawing functions are implemented for the (N)LFSRs, but not for FILFUNs. While the LFSR feedbacks are drawn precisely, the NLFSR feedbacks are a simple box with the multivariate polynomial. For both LFSRs and NLFSRs, two options exist for the state: wide state and narrow state (users preference, and two different functions exist for each: regular FSR and external FSR (the latter with the keyword <em>ext</em> in the function name). The wide and narrow state are also distinguished with keywords <em>W</em> and <em>N</em> in the function name.</p>

<p>Additional tex package <em>tikz</em> must be used.</p>

<p><a id="X7F43CAC08616D8FE" name="X7F43CAC08616D8FE"></a></p>

<h5>3.3-1 TikzW_LFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzW_LFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzN_LFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzW_extLFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzN_extLFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">TikzW_LFSR</code> and <code class="code">TikzN_LFRS</code> draw the <var class="Arg">lfsr</var> with wide or narrow state, i.e. the stage boxes are wider when <em>W</em> function call is used. The wider stage boxes are actually just taller and are useful to indicate that the <code class="func">UnderlyingField</code> (<a href="chap2_mj.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>) of the <var class="Arg">lfsr</var> is an extension field. The feedback is drawn with XOR gates and multiplications by coefficients that are different from 1. All the output taps specified by <code class="func">OutputTap</code> (<a href="chap2_mj.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>) are also shown.</p>

<p><code class="code">TikzW_extLFSR</code> and <code class="code">TikzN_extLFSR</code> draw the extra external element <span class="SimpleMath">\(e\)</span> added to the feedback before updating the vacant stage.</p>

<p><img src="DrawLFSR1.jpg" align="center" /> <img src="DrawLFSR2.jpg" align="center" /></p>

<p><a id="X848A126786051CAF" name="X848A126786051CAF"></a></p>

<h5>3.3-2 TikzW_NLFSR</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzW_NLFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzN_NLFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzW_extNLFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TikzN_extNLFSR</code>( <var class="Arg">output</var>, <var class="Arg">lfsr</var>, <var class="Arg">strGen</var>, <var class="Arg">gen</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">TikzW_NLFSR</code> and <code class="code">TikzN_NLFRS</code> draw the <var class="Arg">nlfsr</var> with wide or narrow state, i.e. the stage boxes are wider when <em>W</em> function call is used. The feedback is drawn as a simple box with <code class="func">MultivarPoly</code> (<a href="chap2_mj.html#X7C6FCBDC82C3734E"><span class="RefLink">2.3-3</span></a>). All the output taps specified by <code class="func">OutputTap</code> (<a href="chap2_mj.html#X828F246B82428CC9"><span class="RefLink">2.1-2</span></a>) are also shown.</p>

<p><code class="code">TikzW_extLFSR</code> and <code class="code">TikzN_extLFSR</code> draw the extra external element <span class="SimpleMath">\(e\)</span> added to the feedback before updating the vacant stage.</p>

<p><img src="DrawNLFSR1.jpg" align="center" /></p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
